<!DOCTYPE html>
<html>
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-163804196-1"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-163804196-1');
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://kit.fontawesome.com/7a312fc647.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" type="text/css" href="../../../../base.css">
    <link rel="stylesheet" type="text/css" href="../../../../article.css">
    <link rel="stylesheet" type="text/css" href="../../../../menu.js">
</head>
<body>
    <div class="menu" id="mymenu">
        <div class="profileCard">
            <img src="../../../../selfie.jpg" alt="Michel" class="photo">
            <h1>Michel Oliveira e Oliveira</h1>
            <div class="title">
                <p>
                    Arquiteto&<br>
                    Engenheiro de Sistemas&<br>
                    Programador&<br>
                    .NET
                </p>
            </div>
            <div class="at">
                <p>@ Banco Safra</p>
            </div>
            <div class="social">
                <a href="https://br.linkedin.com/in/michel-oliveira-arquitetura-ti" target="_blank"><span><i class="fab fa-linkedin"></i></span></a>
                <a href="https://github.com/oliveira-michel" target="_blank"><span><i class="fab fa-github"></i></span></a>
            </div>
        </div>
        <div class="links">
            <div class="home">
                <a href="../../../../index.htm" class="active">Home</a>
            </div>
            <div class="hashTags"><a href='../../../../index.htm#.net' onclick="filterHashTag('.net')">#.net</a>
<a href='../../../../index.htm#rest' onclick="filterHashTag('rest')">#rest</a>
<a href='../../../../index.htm#web' onclick="filterHashTag('web')">#web</a></div>
        </div>
    </div>
    <div class="content">
<div class="imageHeader" style="background-image: url('header.jpg')"></div><h1 id="definindo-contratos-de-rest-apis"><a id="definindo-contratos-de-rest-apis"></a>Definindo contratos de REST APIs</h1>
<ul>
<li><a href="#introdu%C3%A7%C3%A3o">Introdução</a>
<ul>
<li><a href="#apis">APIs</a></li>
<li><a href="#rest-api">REST API</a></li>
</ul>
</li>
<li><a href="#entendendo-e-representando-o-neg%C3%B3cio">Entendendo e representando o negócio</a></li>
<li><a href="#vamos-%C3%A0-pr%C3%A1tica---iniciando-o-domain-model">Vamos à prática - Iniciando o Domain Model</a>
<ul>
<li><a href="#como-identificar-entidades">Como identificar entidades</a></li>
<li><a href="#como-identificar-servi%C3%A7os">Como identificar serviços</a></li>
</ul>
</li>
<li><a href="#conceitos-b%C3%A1sicos-de-rest">Conceitos básicos de REST</a>
<ul>
<li><a href="#recursos">Recursos</a></li>
<li><a href="#a%C3%A7%C3%B5es">Ações</a></li>
<li><a href="#representa%C3%A7%C3%B5es">Representações</a></li>
</ul>
</li>
<li><a href="#o-funcionamento-de-uma-chamada-em-rest">O funcionamento de uma chamada em REST</a></li>
<li><a href="#filtrando-resultados">Filtrando Resultados</a></li>
<li><a href="#transformando-o-modelo-em-recursos-e-verbos-de-rest-apis">Transformando o modelo em recursos e verbos de REST APIs</a></li>
<li><a href="#escrevendo-o-contrato">Escrevendo o contrato</a></li>
<li><a href="#palavras-finais">Palavras finais</a></li>
</ul>
<h2 id="introducao"><a id="introdu&#231;&#227;o"></a>Introdução</h2>
<p>APIs sejam no padrão REST - que a gente vai explorar melhor neste texto - ou outros quaisquer como os variantes de RPC ou GraphQL, já se provaram faz tempo como boas soluções para comunicação entre sistemas.</p>
<p>É praticamente obrigatória em sistemas modernos e muito útil em sistemas legados, pois ajudam a criar uma camada de desacoplamento e abstração da complexidade do que é considerado legado, dando uma &quot;cara&quot; mais aderente com os padrões mais modernos de software.</p>
<p>Nas APIs são definidos contratos (com campos de entrada e saída) que são respeitados pela parte que consome e pela parte que fornece a informação e mesmo que haja alterações internas em qualquer um dos lados, as partes respeitam este contrato não obrigando a outra parte a fazer ajustes no software.</p>
<p>O contrato é algo evolutivo e pode agregar novas funcionalidades com o passar do tempo, principalmente se adotadas as melhores práticas na sua definição e versionamento.</p>
<p>E justamente na definição do contrato que observo que a capacidade de &quot;análise do sistema&quot; parece ter sido colocada em segundo plano por muitos desenvolvedores. Talvez por conta de abrirmos mão da documentação conforme manifesto ágil e não adotarmos as outras práticas de entendimento do problema conforme o próprio ágil define; talvez, porque parar para pensar no sistema sem produzir nenhuma linha de código pode parecer improdutivo para muitos de nós. No entanto, negligenciar esta etapa de análise, traz atrasos, refatorações e posterga alguns tipos de problemas para o momento em que poderíamos estar apenas transformando café em código.</p>
<p>Quando fazemos APIs pensando primeiro no contrato (contract first), trazemos um nível de maturidade muito maior de entendimento da solução como um todo, antes mesmo de começar a programar. Além de iniciar o desenvolvimento com um artefato (contrato) que pode agilizar geração de código fonte, mocks, documentação etc.</p>
<p>O propósito deste guia é trazer em caráter introdutório como é o processo de entender o negócio e montar um contrato de REST API.</p>
<blockquote>
<p>Após a leitura deste guia, recomendo a leitura do <a href="https://github.com/oliveira-michel/guias-api/blob/master/design-rest-api/guia.md">Guia de Design REST</a> que aprofunda bem em alguns conceitos e serve como material de referência.</p>
</blockquote>
<h2 id="apis"><a id="apis"></a>APIs</h2>
<p><strong>API</strong> significa <strong>A</strong>pplication <strong>P</strong>rogramming <strong>I</strong>nterface, ou seja, é um interface para que um programa possa se comunicar com outro programa diferente. APIs podem ser bibliotecas (.dll), trechos de código, endereços na internet, frameworks etc. O importante é que ela permite que um sistema acesse as suas funções de outro sistema sem conhecer seus detalhes internos.</p>
<p>Hoje, quando nos referimos às APIs, já subentendemos que a comunicação entre os sistemas se dá através de sistemas conectados em rede - ou internet - e, na maioria dos casos, se comunicando através do protocolo HTTP (protocolo da internet).</p>
<p>Além de expor as informações do sistema através de um contrato, que é o foco deste texto, APIs usadas para conectar sistemas em rede costumam trazer consigo padrões arquiteturais que trazem capacidades importantes para tratamento da comunicação. Por exemplo:</p>
<ul>
<li><p>API Gateways que fazem o roteamento das mensagens para diversos tipos de sistemas, garantem a aplicação de políticas de segurança, controlam o volume de acessos etc.</p>
</li>
<li><p>APIs que podem ser programadas para orquestrar, compor e transformar informações do sistema afim de abstrair algumas complexidades e facilitar o uso pelo sistema cliente.</p>
</li>
<li><p>Sistemas de cache acoplados na API ou no API Gateway podem armazenar respostas para requisições já feitas anteriormente em ambientes de alta performance e baixo custo em relação ao gasto de ter de fazer todo o processamento novamente.</p>
</li>
<li><p>Padronização de protocolos que fazem com que o consumidor não se preocupe com detalhes da linguagem e ambiente de execução do sistema que processa as informações. Permitindo até que o sistema que processa a informação possa ter partes do seu ambiente em uma linguagem e partes em outras.</p>
</li>
</ul>
<p>Hoje, é praticamente unânime o uso do HTTP, dado que é um protocolo amplamente conhecido em ambientes distribuídos (web), mas mesmo dentro dele, algumas tecnologias que já  tiveram seu auge e caíram em desuso:</p>
<ul>
<li><p>RPC (<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all), em que não haviam regras rígidas com relação ao formato da mensagem trafegada e apenas se trafegava qualquer texto via HTTP.</p>
</li>
<li><p>SOAP (<strong>S</strong>imple <strong>O</strong>bject <strong>A</strong>ccess <strong>P</strong>rotocol), comumente chamado de WebService, endereçou bem questões como segurança e formato de mensagem. Entregou um nível maior de padronizações e permitiu criação de frameworks que facilitavam bastante para o desenvolvedor em utilizar esse padrão. Trafegava XML.</p>
</li>
</ul>
<p>Então, populariza-se o REST com a chegada dos dispositivos móveis com baixo poder de processamento e pouca de banda de internet, trazendo junto o JSON como formato da mensagem, que é um padrão muito mais enxuto. O REST, em relação ao SOAP que usava XML e muitas estruturas para definir a mensagem, foi mais econômico no que diz respeito ao consumo de banda, processador e memória.</p>
<h2 id="rest-api"><a id="rest-api"></a>REST API</h2>
<p>REST API (<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer Application Programming Interface) é um estilo de arquitetura que define um conjunto de restrições e propriedades baseadas em HTTP fornecendo interoperabilidade entre sistemas de computadores na internet (ou rede local). REST permite que os sistemas consumidores acessem e manipulem representações textuais de recursos - as &quot;coisas&quot; da vida real em REST se chamam recursos - usando um conjunto pré definido de operações.</p>
<p>Por colocar mais restrições do que WebServices SOAP e utilizar mais recursos já nativos do protocolo HTTP, acabou padronizando bastante a forma de comunicação e isso agilizou o desenvolvimento das integrações.</p>
<p>O REST enfatiza::</p>
<ul>
<li><p><strong>Simplicidade</strong> através de uma comunicação bem definida, com algumas restrições que facilitam a padronização e stateless, ou seja, todas as informações necessárias para o processamento de uma requisição devem estar contidas naquela requisição.</p>
</li>
<li><p><strong>Extensibilidade</strong> dado que um determinado recurso pode ser representado em diferentes formatos e até mesmo versões, além da possibilidade de se adicionar novos recursos sem precisar alterar os já existentes.</p>
</li>
<li><p><strong>Confiabilidade</strong> porque existe uma definição clara das ações que podem ser feitas e dos seus efeitos colaterais.</p>
</li>
<li><p><strong>Performance</strong> porque faz parte dos principais pilares do REST o uso de cache em todas as camadas possíveis através de uma semântica bem definida, além de uma arquitetura baseada em separação de camadas, permitindo que partes diferentes do sistema possam ser escaladas de forma independente e isolada.</p>
</li>
</ul>
<p>A maioria dos softwares nos quais nós interagimos são construídos para atender às necessidades humanas e normalmente referenciam as &quot;coisas&quot; reais das quais esses softwares tratam. Por exemplo, um software de biblioteca vai representar livros, seções, autores etc. e, através de alguma interface, permitir que um usuário interaja com estas representações. Uma API difere-se deste tipo de software no que tange o usuário: quem interage com o software é outro software, não diretamente o usuário final. No entanto, quem desenvolve o software que interage com a API é um programador e para que a experiência deste programador e do usuário do software que ele desenvolve seja a melhor possível, princípios de design devem ser respeitados.</p>
<p>O assunto que será abordado no próximo capítulo é sobre <strong>como definir os contratos das APIs</strong>. Não entrarei em conceitos avançados de REST, arquitetura REST (camadas), implementação do código fonte, autenticação, entre outros assuntos que permeiam a integração via REST pelo simples fato de que eles já estão muito bem documentados na web. Alguns conceitos serão brevemente explicados para permitir que o processo de definição do contrato seja entendido e conceitos específicos de design pode ser aprofundados neste material: <a href="https://github.com/oliveira-michel/guias-api/blob/master/design-rest-api/guia.md">Design de REST API</a>.</p>
<h2 id="entendendo-e-representando-o-negocio"><a id="entendendo-e-representando-o-neg&#243;cio"></a>Entendendo e representando o negócio</h2>
<p>O primeiro grande desafio ao se construir qualquer software deveria ser entender o negócio sobre o qual o software trata. Muitas vezes, essa etapa de entendimento é ignorada e o software produzido acaba não refletindo o negócio como ele é. Quando isso acontece, as alterações que aos olhos de negócio pareceriam simples, quando são orçadas pela TI, descobre-se que são mais complexas e caras do que o imaginado.</p>
<p>Para ajudar a entender o negócio e representá-lo de uma forma que possa ser entendido desde o analista de negócio até o desenvolvedor, pode ser feito um Domain Model. O Domain Model é um dos muitos conceitos do Domain Driven Design (DDD).</p>
<p>O DDD fornece um conjunto de recursos e padrões que ajudam a documentar e modelar software. O DDD ganhou notoriedade recentemente por facilitar o recorte de Microsserviços.</p>
<p>O Domain Model é uma representação de conceitos do mundo real (do negócio) que são pertinentes ao um ou mais domínios a serem trabalhados em um software. Estes conceitos incluem as entidades e as relações entre elas. No entanto, não faz parte de um Domain Model implementações técnicas como banco de dados ou componentes específicos de software.</p>
<p><img src="https://github.com/oliveira-michel/guias-api/blob/master/definindo-contratos-rest-api/resources/exemplo-domain-model.png?raw=true" alt="Exemplo de um Domain Model suficiente para começar a definir APIs"></p>
<p><sub>Exemplo de um Domain Model suficiente para começar a definir APIs</sub></p>
<p>O Domain Model quando pronto, mesmo com um modelo simplificado como o do exemplo acima, parece simples e deve ser simples, no entanto, a riqueza de se modelar o domínio está mais no processo da criação dele do que no resultado final. Durante o processo de criação do Domain Model, deve-se alinhar o entendimento do time sobre os melhores nomes para representar as entidades de negócio e as relações entre elas. Neste processo muitas divergências ocorrem entre o que é o negócio como a área de negócio entende, o que é o sistema no estado atual e o que algumas pessoas têm em mente como visão futura daquele ambiente. Muitas vezes o analista com mais profundidade nos conceitos do Domain Driven Design precisa orientar o time sobre os conceitos e objetivo do Domain Model.</p>
<p>Alguns conceitos úteis podem guiar o processo da criação do Domain Model:</p>
<ul>
<li><p><strong>Bounded Context</strong>: São fronteiras (no exemplo acima representadas por tracejado) que separam conceitos que têm alguma relação entre si. Não existem regras rígidas para criação de bounded context, mas o significado desta fronteira deve ser claro para todo o time. Um bounded context pode inspirar divisões para softwares diferentes, contratos de APIs diferentes, componentes diferentes, etc.</p>
</li>
<li><p><strong>Ubiquitous Language</strong>: Linguagem ubíqua, em português, é o uso da linguagem falada que seja de conhecimento comum entre todos os envolvidos com um conceito de negócio: o jargão. Um conceito de negócio deve ter um nome único e seu significado deve ser claro para todos. Devemos buscar utilizar estes nomes adotados em todo o software, desde o linguajar usado no dia a dia à telas, programação, bancos de dados, etc. Um dos pontos fortes do DDD é o resgate e reforço do uso de uma notação ubíqua entre os domain experts (quem conhece do negócio) e área de TI e o outro é a busca pela simplificação. Alguém sem conhecimento de um determinado negócio, deveria ser capaz de aprender sobre ele apenas lendo o código do sistema. E alguém com conhecimento de negócio deveria ter facilidade em usar e até mesmo entender a estrutura de dados e funções codificadas apenas reconhecendo os termos lá presentes. Um software que não tem suas raízes plantadas profundamente no domínio, não irá se adaptar bem às mudanças com o passar do tempo.</p>
</li>
</ul>
<p>O Domain Driven Design tem muitos conceitos: é como uma grande caixa de ferramentas. Neste guia para definição de contratos de APIs, somente alguns deles já serão suficientes para atingir o objetivo.</p>
<h2 id="vamos-a-pratica-iniciando-o-domain-model"><a id="vamos-&#224;-pr&#225;tica---iniciando-o-domain-model"></a>Vamos à prática - Iniciando o Domain Model</h2>
<p>Primeiramente, é necessário identificar as <strong>entidades</strong> do negócio. Entidades são os nomes genéricos que damos às coisas, como &quot;carro&quot;, &quot;livro&quot;, &quot;cartão&quot;, &quot;conta&quot;, etc.</p>
<p>Uma entidade é uma representação de um conjunto de informações sobre determinado conceito do sistema. Estas informações são os <strong>atributos</strong>, que juntos representam a entidade.</p>
<p>Entidades têm <strong>identificadores</strong> e através dos identificadores, distinguimos duas instâncias diferentes da mesma entidade. Por exemplo, se existir uma entidade carro, como se distingue dois Fuscas azuis fabricados no mesmo dia? Neste caso, pode-se usar o número do chassi como identificador da entidade.</p>
<p>Enquanto um analista de sistemas ou de negócio está explicando a ideia do software, já podemos identificar no falar da pessoa algumas possíveis entidades. Durante o falar, já é interessante ir anotando o que for identificado.</p>
<h3 id="como-identificar-entidades"><a id="como-identificar-entidades"></a>Como identificar entidades</h3>
<p>O que &quot;tem cara&quot; de ser entidade:</p>
<ul>
<li>Recursos (coisas) que têm um identificador. Por exemplo: conta corrente tem um número que a representa, cartão de crédito tem um número, carro tem chassi, aparelho celular tem imei, placa de rede tem MAC adress, pessoas têm documentos, etc.</li>
<li>Palavras que vêm depois de frases como: &quot;- Aí eu gravo a .&quot;, &quot;- Então eu trago uma lista de .&quot;, &quot;O usuário escolhe uma .&quot;.</li>
<li>Definições de negócio que não têm um identificador, mas você consegue identificar unitariamente entre todos. Por exemplo: &quot;A fatura do mês 08 de 2017.&quot;</li>
<li><strong>Substantivos</strong>.</li>
</ul>
<p>O que não &quot;tem cara&quot; de ser entidade:</p>
<ul>
<li>Definições de negócio que não têm ID, nem é possível identificá-las unitariamente entre todos.</li>
<li>Definições que têm como nome &quot;gravação&quot;, &quot;listagem&quot;, &quot;detalhes&quot;, &quot;dados&quot;, &quot;informações&quot; entre outros termos vagos. Esse tipo de nomenclatura provavelmente precisa ser refinada e talvez desse refinamento, surja uma entidade.</li>
<li>Verbos.</li>
</ul>
<p>Tendo entendido este conceito de entidade, podemos fazer um primeiro desenho sobre o negócio de cartões representando as principais entidades. Para esse exemplo, usei um caso semelhante ao real em ambiente bancário. As soluções deste guia são para fins didáticos, então vamos chegar em um resultado próximo ao real, mas simplificado.</p>
<p><img src="https://github.com/oliveira-michel/guias-api/blob/master/definindo-contratos-rest-api/resources/domain-model-1.png?raw=true" alt="Domain Model Simplificado de Cartões"></p>
<p><sub>Domain Model Simplificado de Cartões.</sub></p>
<p>Antes do processo de desenhar as entidades, durante ou depois - a ordem não importa -  é preciso entender também quais são as funções de negócio que serão disponibilizadas. Para usar como exemplo para este guia, vamos inventar algumas necessidades de negócio que são semelhantes às reais:</p>
<ul>
<li>listar os cartões em que é possível fazer grade (upgrade ou downgrade);</li>
<li>ofertar possibilidades de grade de cartão;</li>
<li>listar os cartões cuja fatura pode ser consultada online;</li>
<li>listar as faturas de um cartão;</li>
<li>listar os cartões que estão com a opção de fatura digital ativada;</li>
<li>listar os cartões em que permitem parcelar a fatura em aberto;</li>
<li>ofertar possibilidades de parcelamento de faturas;</li>
<li>contratar parcelamento de faturas;</li>
</ul>
<p>Enquanto para identificar as entidades focamos nos substantivos, da lista de funções precisamos focar nos verbos:</p>
<ul>
<li>listar</li>
<li>ofertar</li>
<li>contratar</li>
</ul>
<p>Veremos mais detalhes sobre REST nos capítulos posteriores, mas aqui já precisamos ter em mente que o REST tem um conjunto de verbos limitados para serem usados. São eles: GET, POST, PUT, PATCH e DELETE. Este conjunto básico de verbos do REST representam operações de CRUD (Create, Read, Update, Delete). Podemos entender que o listar é na verdade uma consulta, logo, será substituído pelo verbo GET que representa uma consulta.</p>
<p>Apesar de muitas situações não requererem grande esforço criativo por apenas exporem as suas entidades e operações de CRUD, muitas APIs vão além disso e precisam refletir funções de negócio como reservar, comprar, simular, transferir, calcular, ofertar, cancelar, contratar, etc. Na lista de verbos acima existem alguns casos nesta situação: ofertar e contratar. Encaixar estes verbos (funções) dentro das restrições do REST é o segundo grande desafio da modelagem de APIs.</p>
<p>Mais pra frente neste guia vamos detalhar esta transformação dos verbos do negócio em verbos do REST, por agora, precisamos apenas identificar que eles estão associados com “coisas” que normalmente têm um ID. Estas funções de negócio não são entidades porque não têm IDs, mas podem ser representados também no Domain Model, principalmente para entender a relação deles com as entidades. Por vezes, essas funções também envolverão várias outras entidades para executar a função. Chamamos estas funções de serviços e podemos colocar também no modelo.</p>
<h3 id="como-identificar-servicos"><a id="como-identificar-servi&#231;os"></a>Como identificar serviços</h3>
<p>O que &quot;tem cara&quot; de ser serviço:</p>
<ul>
<li>Recursos que cuja resposta varia conforme um conjunto de filtros e não são armazenados no banco de dados, como algumas simulações e cálculos.</li>
<li>Recursos que retornam resultados que não têm ID, como extratos, francesinha, saldo, posição consolidada, etc.</li>
<li><strong>Verbos</strong>.</li>
</ul>
<p>O que &quot;não tem cara&quot; de ser serviço:</p>
<ul>
<li>Verbos que representam CRUD, como listar, gravar, apagar etc.</li>
<li>Recursos que têm ID e são armazenados em banco de dados.</li>
<li>Substantivos.</li>
</ul>
<p><img src="https://github.com/oliveira-michel/guias-api/blob/master/definindo-contratos-rest-api/resources/domain-model-2.png?raw=true" alt="Domain Model Simplificado de Cartões"></p>
<p><sub>Domain Model de Cartões com alguns serviços.</sub></p>
<p>Agora, precisamos pensar em dividir os assuntos que estamos trabalhando. Mesmo o modelo não estando 100% refinado, já podemos recortar os assuntos semelhantes através de bounded contexts. O Domain Driven Design não define rigidamente os critérios para executar estes recortes, no entanto, uma coisa é regra: o recorte deve ser consensual entre os analistas do negócio. Não sendo, deve-se buscar o alinhamento.</p>
<p>No modelo abaixo, separamos os assuntos de cartões de outros assuntos que fazem parte do banco, mas não diretamente do negócio de cartões. Por vezes, este recorte será relacionado aos domínios, subdomínios e/ou grupos funcionais, outras vezes será um produto específico.</p>
<p><img src="https://github.com/oliveira-michel/guias-api/blob/master/definindo-contratos-rest-api/resources/domain-model-3.png?raw=true" alt="Domain Model Simplificado de Cartões"></p>
<p><sub>Domain Model de Cartões com bounded contexts.</sub></p>
<p>Até o ponto que chegamos podemos observar que já temos um diagrama que facilita a explicação do negócio para qualquer pessoa dentro ou fora do contexto desse negócio. O principal ponto é que até para que diagramas simples como este muita discussão acontece e com ela alinhamentos e compartilhamento de conhecimento.</p>
<p>Para a apresentação do Domain Model não há um formato rígido: já trabalhei com times que fizeram em ferramentas de UML, em apresentação de slides, em folha de caderno e a grande maioria foram rabiscados em mesas de vidro e registrados com foto no celular. Isso já foi suficiente para geração de algumas centenas de boas modelagens de contratos de API durante minha carreira.</p>
<p>Por ora, paramos por aqui com Domain Driven Design para absorver outros conceitos novos.</p>
<h2 id="conceitos-basicos-de-rest"><a id="conceitos-b&#225;sicos-de-rest"></a>Conceitos básicos de REST</h2>
<h3 id="recursos"><a id="recursos"></a>Recursos</h3>
<p>Recursos no REST são os &quot;substantivos&quot; do seu sistema. São as entidades que serão expostas para outros sistemas. Os recursos são representados através de URLs (Uniform Resource Location) como a dos sites na web.</p>
<p>Exemplos de recursos representados por URLs:</p>
<ul>
<li>Representação das artistas do Spotify: <a href="https://api.spotify.com/v1/artists/">https://api.spotify.com/v1/artists/</a></li>
<li>Representação dos álbuns do Spotify: <a href="https://api.spotify.com/v1/albums">https://api.spotify.com/v1/albums</a></li>
<li>Representação de um álbum específico do Spotify: <a href="https://api.spotify.com/v1/albums/%7Bid%7D">https://api.spotify.com/v1/albums/{id}</a></li>
<li>Representação das trilhas de um álbum do Spotify: <a href="https://api.spotify.com/v1/albums/%7Bid%7D/tracks">https://api.spotify.com/v1/albums/{id}/tracks</a></li>
</ul>
<p>Estes substantivos representados pelas URLs representam o &quot;S&quot; de &quot;State&quot; do RE<strong>S</strong>T. Isso significa que existe uma representação do estado de um recurso. Estado é como um recurso se encontra em um momento: é a situação atual dos dados de uma entidade em um determinado instante.</p>
<h3 id="acoes"><a id="a&#231;&#245;es"></a>Ações</h3>
<p>Clientes de REST APIs alteram o estado dos recursos, ou seja, alteram suas propriedades através de 5 ações. Existem outras, mas essas são as principais:</p>
<ul>
<li>Consultar, que utiliza o verbo GET do HTTP;</li>
<li>Criar Novo, que utiliza o verbo POST do HTTP;</li>
<li>Substituir, que utiliza o verbo PUT do HTTP;</li>
<li>Atualizar parcialmente, que utiliza o verbo PATCH do HTTP;</li>
<li>Apagar, que utiliza o verbo DELETE do HTTP.</li>
</ul>
<p>Estas ações também são chamadas de verbos ou métodos. Elas representam o &quot;T&quot; de &quot;transfer&quot; do RES<strong>T</strong>. Isso significa que você está transferindo o recurso de um estado para outro.</p>
<p>Outro conceito importante no que tange os verbos é sobre ser seguro e/ou idempotente.</p>
<p>Consumidores de REST APIs quando utilizam verbos seguros, entendem que eles não alteram o estado dos recursos quando fazem uma requisição. Ou seja, podem fazer uma tentativa de requisição e, se falhar, simplesmente tentar de novo, pois sabem que não estão fazendo alterações no sistema.</p>
<p>Consumidores de REST APIs quando utilizam verbos idempotentes, entendem que eles podem executar várias vezes a requisição e terão o mesmo resultado inicial.</p>
<p>Por exemplo:</p>
<ul>
<li>GET é seguro, ao usá-lo, é feita uma consulta no backend da e nada é alterado.</li>
<li>GET é idempotente, posso chamá-lo várias vezes e terei o mesmo recurso como retorno.</li>
<li>POST não é seguro, pois quando é feita uma requisição com POST, ele cria coisas novas no backend.</li>
<li>POST não é idempotente, pois a cada vez que eu faço uma requisição com POST, ele cria um recurso novo.</li>
<li>PUT não é seguro, pois quando é feita uma requisição com PUT, ele altera do estado do recurso no backend.</li>
<li>PUT é idempotente, pois a cada vez que eu faço uma requisição com PUT, ele altera da mesma forma o recurso.</li>
</ul>
<p>O mais importante sobre segurança e idempotência é que na modelagem de contratos de APIs sejam respeitados os propósitos dos verbos, porque por se tratar de um padrão, os consumidores têm uma expectativa de funcionamento destes verbos. Logo, se você cria uma API em que um GET altera estado de recursos, um consumidor, poderá estar alterando o estado deste recurso de forma não intencional.</p>
<p>Faz parte também do protocolo HTTP o uso de códigos de retorno para entender quando uma requisição foi bem ou mal sucedida. Os códigos são compostos de 3 dígitos e de forma genérica:</p>
<ul>
<li>200 significa que a requisição foi bem sucedida</li>
<li>300 significa que a requisição foi redirecionada para outra URL</li>
<li>400 significa que o usuário cometeu um erro</li>
<li>500 significa que ocorreu um erro no servidor</li>
</ul>
<p>E cada um deles pode se desdobrar em outros mais específicos, por exemplo:</p>
<ul>
<li>201 (sucesso) significa que um recurso foi criado</li>
<li>206 (sucesso) significa que a resposta está paginada</li>
<li>403 (erro do requisitante) significa que o usuário não tem acesso naquele recurso</li>
<li>404 (erro do requisitante) significa que a URL (recurso) não existe</li>
<li>503 (erro do servidor) significa que o servidor não está disponível</li>
</ul>
<p>Então, é parte do processo executar uma ação em uma API através de um dos verbos e receber um código de retorno indicando o status daquela requisição. Como os códigos são padrões, a aplicação poderá implementar comportamentos padrões conforme os códigos de retorno.</p>
<h3 id="representacoes"><a id="representa&#231;&#245;es"></a>Representações</h3>
<p>Representações é a forma como os clientes da API vêem os recursos. Os clientes de APIs enxergam estas representações do recurso.</p>
<p>Por exemplo, uma pessoa para um sistema está armazenada em uma tabela no banco de dados, mas a representação deste recurso para o cliente se dá através de um JSON com alguns campos, talvez nem todos os campos da tabela e talvez com alguns filtros, mas o acesso direto à tabela (recurso), ele não tem. Nesta mesma linha, a imagem da pessoa pode estar em um file server dentro da empresa, e através da API esta imagem é exposta como JPG. O usuário tem acesso à representação da imagem original, talvez com resolução menor, talvez com restrições de acesso e não tem direto acesso ao recurso original no file server.</p>
<p>Estas representações são o &quot;RE&quot; de &quot;representational&quot; do <strong>RE</strong>ST.</p>
<h2 id="o-funcionamento-de-uma-chamada-em-rest"><a id="o-funcionamento-de-uma-chamada-em-rest"></a>O funcionamento de uma chamada em REST</h2>
<p>Suponha a existência de uma API que informe o clima. Ela estaria exposta em uma URL semelhante a essa <a href="http://conhecasaopaulo.com/temperatura/">http://conhecasaopaulo.com/temperatura/</a> e o servidor responde a temperatura através de uma representação em JSON.</p>
<p>Em HTTP a comunicação se dá através de um Request com a requisição de alguma informação e um Response com a resposta da requisição. Por se tratar de uma consulta, utiliza-se um dos verbos do HTTP, o GET. Como a requisição foi bem sucedida, foi retornado o HTTP status code 200.</p>
<p>Ex:</p>
<pre><code>Request
GET http://conhecasaopaulo.com/temperatura/

Response
HTTP 200 Ok 
{&quot;celsius&quot;: 14, &quot;fahrenheit&quot;: 57}
</code></pre>
<p>Para envio desta requisição e recepção da resposta em HTTP, quase todas as linguagens de programação têm funções que permitem fazê-la.</p>
<p>Para transformar a representação em JSON em um objeto a ser manipulado, as linguagens de programação também têm funções que fazem esta conversão de forma automática.</p>
<h2 id="filtrando-resultados"><a id="filtrando-resultados"></a>Filtrando Resultados</h2>
<p>Imagine a existência de um recurso que represente os restaurantes de São Paulo. Uma busca por eles seria algo como:</p>
<pre><code>Request
GET http://conhecasaopaulo.com/restaurantes

Response
HTTP 200 Ok
{ 
   [ 
      { 
         &quot;id&quot;:1,
         &quot;nome&quot;:&quot;Restaurante A&quot;,
         &quot;bairro&quot;:&quot;Pinheiros&quot;,
         &quot;endereço&quot;:&quot;Rua XPTO, 123&quot;,
         &quot;telefone&quot;:&quot;11 912345678&quot;
      },
      { 
         &quot;id&quot;:2,
         &quot;nome&quot;:&quot;Restaurante B&quot;,
         &quot;bairro&quot;:&quot;Mooca&quot;,
         &quot;endereco&quot;:&quot;Rua ABCD, 234&quot;,
         &quot;telefone&quot;:&quot;11 345678922&quot;
      },
      ...
   ]
}
</code></pre>
<p>No entanto, esta lista pode ser realmente grande e tornar lenta uma possível busca onde queremos apenas alguns restaurantes conforme algum critério, não todos.</p>
<p>Para fazer filtragem usamos query parameters. Query parameters fazem parte da URL do HTTP e são representados por conjuntos chave/valor iniciados com interrogação e separados por &quot;e&quot; comercial.</p>
<p>Ex: http://.../...?chave1=valor1&amp;chave2=valor2&amp;chave3=valor3</p>
<p>Logo, caso você queira filtrar a lista de restaurantes por bairro, por exemplo, utilizamos os query parameters para fazer o filtro no recurso.</p>
<pre><code>Request
GET http://conhecasaopaulo.com/restaurantes?bairro=Pinheiros

Response
HTTP 200 Ok 
{ 
  [ 
      { 
         &quot;id&quot;:1,
         &quot;nome&quot;:&quot;Restaurante A&quot;,
         &quot;bairro&quot;:&quot;Pinheiros&quot;,
         &quot;endereço&quot;:&quot;Rua XPTO, 123&quot;,
         &quot;telefone&quot;:&quot;11 912345678&quot;
      }
      ...
   ]
}
</code></pre>
<h2 id="transformando-o-modelo-em-recursos-e-verbos-de-rest-apis"><a id="transformando-o-modelo-em-recursos-e-verbos-de-rest-apis"></a>Transformando o modelo em recursos e verbos de REST APIs</h2>
<p>Tendo aprendido algumas das características do REST, já podemos começar a transformar nossa especificação de negócio em um contrato de API.</p>
<p>E para cada uma dos serviços ou entidades identificados no Domain Model, devemos fazer os seguintes questionamentos:</p>
<p><em><strong>1 - Qual é o mapeamento entre os verbos HTTP e os verbos das funcionalidades do meu negócio?</strong></em></p>
<p>Os “listar” são mais óbvios e representam consultas, logo, para consultas no REST usamos o verbo GET.</p>
<p>Pensando na chamada REST, o servidor está parado e recebe uma requisição, logo, o “ofertar” não é uma ação iniciada pelo servidor, mas pelo cliente da API que “buscará” uma oferta de algo. Assim, essa busca é na verdade uma consulta a um conjunto de informações, logo, usaremos também o verbo GET.</p>
<p>Para o “contratar”, não temos uma ação segura, pois eu crio um estado novo no lado do servidor através da gravação da contratação, neste caso, usaremos o verbo POST.</p>
<p>Fazendo a devida substituição:</p>
<ul>
<li>listar: GET dos cartões em que é possível fazer grade (upgrade ou downgrade);</li>
<li>ofertar: GET de possibilidades de grade de cartão;</li>
<li>listar: GET das faturas de um cartão;</li>
<li>listar: GET dos cartões que estão com a opção de fatura digital ativada;</li>
<li>listar: GET dos cartões em que permitem parcelar a fatura em aberto;</li>
<li>ofertar: GET de possibilidades de parcelamento de faturas;</li>
<li>contratar: POST parcelamento de faturas;</li>
</ul>
<p><em><strong>2 - Que recursos em formato de URL serão criados para cada entidade ou serviço do meu negócio?</strong></em></p>
<p>Analisando o Domain Model, transformamos as funcionalidades e os verbos definidos na questão anterior em recursos na URL:</p>
<ul>
<li>GET dos cartões http://.../cartoes em que é possível fazer grade (upgrade ou downgrade)</li>
</ul>
<p>A entidade a ser retornada são os cartões.</p>
<ul>
<li>GET de possibilidades de grade de cartão http://.../cartoes//ofertas-upgrade</li>
</ul>
<p idcartao="">O recurso a ser retornado são ofertas de upgrade de cartão. Essas ofertas de cartão são feitas sempre à partir de um cartão existente (). Por isso, ela é relacionada a um cartão e aparece na URL como um sub-recurso.</p>
<ul>
<li>GET das faturas de um cartão http://.../cartoes//faturas/</li>
</ul>
<p idcartao="">O recurso a ser retornado são as faturas de um cartão específico () e existe uma fatura por mês. Cada uma dessas faturas terá o seu ID.</p>
<ul>
<li>GET dos cartões  http://.../cartoes que estão com a opção de fatura digital ativada</li>
</ul>
<p>O recurso a ser retornado são os cartões que têm uma característica de disponibilizar a fatura apenas online.</p>
<ul>
<li>GET dos cartões http://.../cartoes em que permitem parcelar a fatura em aberto</li>
</ul>
<p>O recurso a ser retornado são os cartões que têm uma característica de permitir o parcelamento da fatura.</p>
<ul>
<li>GET de possibilidades de parcelamento de faturas http://.../cartoes//ofertas-parcelamentos-fatura</li>
</ul>
<p idcartao="">O recurso a ser retornado é um serviço que faz ofertas de parcelamentos de faturas pré calculadas. As ofertas são para um cartão específico por isso, o recurso é relacionado com um cartão já existente ().</p>
<ul>
<li>POST parcelamento de faturas http://.../cartoes//faturas//parcelamento/</li>
</ul>
<p idfatura="">O recurso é um serviço que grava uma escolha de parcelamento. O parcelamento é de uma fatura específica, por isso, o recurso é relacionado com uma fatura já existente ().</p>
<p><em><strong>3 - Para cada verbo + URL, quais são os parâmetros de entrada?</strong></em></p>
<ul>
<li>GET http://.../cartoes?upgrade=true</li>
</ul>
<p>A entidade a ser retornada são os cartões que tenham uma característica de permitir upgrade. No caso, dentre todos os existentes, faremos um filtro através do query parameter upgrade=true.</p>
<ul>
<li>GET http://.../cartoes//ofertas-upgrade</li>
</ul>
<p idcartao="">O recurso a ser retornado são ofertas de cartões. Oferta de cartão não é a entidade de cartão que representa os cartões já existentes de um cliente e as ofertas são feitas sempre à partir de um cartão existente (). Por isso, ela é relacionada a um cartão e aparece na URL como um sub-recurso.</p>
<ul>
<li>GET http://.../cartoes//faturas/</li>
</ul>
<p idcartao="">O recurso a ser retornado são as faturas de um cartão específico () e existe uma fatura por mês. Cada uma dessas faturas terá o seu ID.</p>
<ul>
<li>GET http://.../cartoes?elegivelFaturaDigital=true</li>
</ul>
<p>O recurso a ser retornado são os cartões que têm uma característica de disponibilizar a fatura apenas online.</p>
<ul>
<li>GET http://.../cartoes?elegivelParcelamentoFatura=true</li>
</ul>
<p>O recurso a ser retornado são os cartões que têm uma característica de permitir o parcelamento da fatura.</p>
<ul>
<li>GET http://.../cartoes//ofertasParcelamentosFatura</li>
</ul>
<p idcartao="">O recurso a ser retornado é um serviço que faz ofertas de parcelamentos de faturas pré calculadas. As ofertas são para um cartão específico, por isso o recurso é relacionado com um cartão já existente ().</p>
<ul>
<li>POST http://.../cartoes//faturas//parcelamento</li>
</ul>
<p>Por se tratar de um POST, os parâmetros vão no body da mensagem, ao contrário das consultas que são via queryparameter.
Assim, precisa identificar quais são esses parâmetros que o consumidor da API envia. Estes parâmetros devem ser relacionados apenas ao serviço de parcelamento e, independente de como é o backend, devem ser escritos de forma a ser o mais auto-explicativo possível, além de ser apenas os campos necessários para o consumidor. Ou seja, nesta camada de API, devemos abstrair a complexidade do backend afim de dar a melhor experiência possível para quem consome e não conhece no detalhe o sistema.</p>
<pre><code>{
   &quot;idConta&quot;: &quot;0004321098765432109&quot;,
   &quot;valorPagamamentoMinimo&quot;: 123456.78,
   &quot;idOferta&quot;: “12P1”,
   &quot;quantidadeParcelas&quot;: 12,
   &quot;valorParcela&quot;: &quot;234.56&quot;,
   &quot;dataPrimeiroVencimento&quot;: &quot;2018-06-20&quot;,
   &quot;dataPagamentoEntrada&quot;: &quot;2018-05-20&quot;,
   &quot;valorEntrada&quot;: 1000.20,
   &quot;valorUltimoPagamento&quot;: 134.67,
   &quot;seguroPrestamista&quot;: false
}
</code></pre>
<p><em><strong>3.1 - Pergunta especial: E o ID do usuário?</strong></em></p>
<p>Talvez você tenha percebido que não é passada identificação do usuário em nenhuma das APIs acima. Isso é porque a identificação do usuário deve vir via token. O uso de token é explicado nas tecnologias <a href="https://oauth.net/2/">OAUTH</a>, <a href="https://openid.net/connect/">Open Id Connect</a> e <a href="https://jwt.io">JWT</a>.</p>
<p>Basicamente, todas as chamadas de API passam no header um texto que pode ser uma chave de busca para recuperar as informações do usuário em um servidor de autenticação, ou um texto em formato base64 que pode ser convertido para JSON e neste JSON está a identificação do cliente e aplicação que chamou a API. Este texto chama-se token.</p>
<p>Então, podemos considerar as informações do usuário logado (cliente) também é um parâmetro de entrada, mas não precisamos definí-lo na API, pois ele é parte do token. Sendo parte do token, quem recebe a informação tem meios de garantir que ela não foi adulterada e foi gerada por um serviço confiável.</p>
<blockquote>
<p>Para conhecer melhor sobre esse assunto, confira estes materiais:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=h4A8HytL5ts">https://www.youtube.com/watch?v=h4A8HytL5ts</a></li>
<li><a href="https://oauth.net/2/">https://oauth.net/2/</a></li>
<li><a href="https://jwt.io/">https://jwt.io/</a></li>
<li><a href="https://openid.net/connect/">https://openid.net/connect/</a></li>
</ul>
</blockquote>
<p><em><strong>4 - Para cada verbo + URL, quais são os parâmetros de saída?</strong></em></p>
<p>Neste ponto, a gente pensa em cada entidade a ser exposta por API envolvida no nosso sistema e define o conjunto de atributos que a representa. Vamos representá-la em JSON, pois é o padrão que será utilizado na hora de programar a API. O exercício de definir estes campos já servirá como base para usar de exemplo na documentação (contrato).</p>
<pre><code>Request
GET http://.../cartoes

Response
{
   &quot;id&quot;: &quot;44723873284&quot;,
   &quot;numero&quot;: &quot;879879879898798798&quot;,
   &quot;nome&quot;: &quot;Cartão XPTO&quot;,
   &quot;nomePortador&quot;: &quot;José da Silva&quot;,
   &quot;dataValidade&quot;: &quot;12/25&quot;,
   &quot;bandeira&quot;: &quot;Mastercard&quot;,
   &quot;parceiro&quot;: &quot;Ipiranga&quot;,
   &quot;cvv&quot;: &quot;789&quot;,
   &quot;dataMelhorCompra&quot;: &quot;2016-02-28&quot;,
   &quot;bloqueado&quot;: false
}
</code></pre>
<pre><code>Request
GET http://.../cartoes/{idCartao}/ofertas-upgrade

Response
{
    &quot;id&quot;: &quot;90909090909&quot;,
    &quot;nomeProduto&quot;: &quot;CARTAO TOP MULTIPLO MATERCARD PLATINUM&quot;,
    &quot;valorAnuidade&quot;: 480,
    &quot;quantidadeParcelasAnuidade&quot;: 12,
    &quot;valorParcelaAnuidade&quot;: 40,
    &quot;beneficios&quot;: [
        {
            &quot;id&quot;: &quot;1&quot;,
            &quot;tituloBeneficio&quot;: &quot;20% descontos em diversos cinemas, teatros e shows&quot;,
            &quot;descricaoBeneficio&quot;: &quot;Curta diversos shows, teatros e cinemas com 20% de desconto!&quot;
        },
        {
            &quot;id&quot;: &quot;2&quot;,
            &quot;tituloBeneficio&quot;: &quot;Compras parceladas&quot;,
            &quot;descricaoBeneficio&quot;: &quot;Parcele o pagamento sem pagar juros ou encargos até o máximo de vezes que o estabelecimento permitir.&quot;
        }
    ]
}
</code></pre>
<pre><code>Request
GET http://.../cartoes/{idCartao}/faturas

Response
{
    &quot;id&quot;: &quot;123123123&quot;,
    &quot;status&quot;: &quot;atual&quot;,
    &quot;totalFatura&quot;: 1000.12,
    &quot;dataVencimento&quot;: &quot;2017-01-29&quot;,
    &quot;dataFechamento&quot;: &quot;2017-01-27&quot;,
    &quot;pagamentoMinimo&quot;: 100.00,
    &quot;taxaJurosFinanciamentoAm&quot;: 1.2,
    &quot;taxaJurosFinanciamentoAa&quot;: 1.3,
    &quot;elegivelFaturaDigital&quot;: true,
    &quot;elegivelPagamentoFatura&quot;: true,
    &quot;lançamentos&quot;: [
        {
            &quot;data &quot;: &quot;2017-10-19&quot;,
            &quot;descricaoLancamento&quot;: &quot;SHOPPING ABC&quot;,
            &quot;valorLancamento&quot;: 72.8
        },
        {
            &quot;data&quot;: &quot;2017-10-23&quot;,
            &quot;descricaoLancamento&quot;: &quot;POSTO AGUIA&quot;,
            &quot;valorLancamento&quot;: 128.70
        }
    ]
}
</code></pre>
<pre><code>Request
GET http://.../cartoes/{idCartao}/ofertasParcelamentosFatura

Response
{
    &quot;id&quot;: &quot;12P1&quot;,
    &quot;quantidadeParcelas&quot;: 12,
    &quot;valorParcela&quot;: 230.10,
    &quot;taxaJuros&quot;: 1.54
}
</code></pre>
<pre><code>Request
POST http://.../cartoes/{idCartao}/faturas/{idFatura}/parcelamento

Response
{
    &quot;idConta&quot;: &quot;0004321098765432109&quot;,
    &quot;valorPagamamentoMinimo&quot;: 123456.78,
    &quot;idOferta&quot;: “12P1”,
    &quot;quantidadeParcela&quot;: 12,
    &quot;valorParcela&quot;: &quot;234.56&quot;,
    &quot;dataPrimeiroVencimento&quot;: &quot;2018-06-20&quot;,
    &quot;dataPagamentoEntrada&quot;: &quot;2018-05-20&quot;,
    &quot;valorEntrada&quot;: 1000.20,
    &quot;valorUltimoPagamento&quot;: 134.67,
    &quot;seguroPrestamista&quot;: false,
    &quot;dataHoraContratacao&quot;: &quot;2018-05-15T21:00:00&quot;
}
</code></pre>
<p><em><strong>5 - Para cada verbo + URL, quais são os códigos de retorno HTTP a serem utilizados?</strong></em></p>
<ul>
<li>GET http://.../cartoes?upgrade=true</li>
<li>GET http://.../cartoes//ofertas-upgrade</li>
<li>GET http://.../cartoes//faturas/</li>
<li>GET http://.../cartoes?elegivelFaturaDigital=true</li>
<li>GET http://.../cartoes?elegivelParcelamentoFatura=true</li>
<li>GET http://.../cartoes//ofertasParcelamentosFatura</li>
</ul>
<p>Em todos os casos acima temos apenas consultas (GET) e os códigos de retorno seguirão o mesmo padrão:</p>
<ul>
<li><p>Quando a resposta é processada com sucesso, trazendo ou não resultados, o código de retorno é um 200 representando sucesso.</p>
</li>
<li><p idcartao="" idfatura="">Caso seja passado algum parâmetro de URL apontando para um recurso que não exista () ou (), deve ser retornado um 404 indicando que a URL (recurso) não existe.</p>
</li>
<li><p idcartao="" idfatura="">POST http://.../cartoes//faturas//parcelamento</p>
</li>
</ul>
<p>Quando se faz um POST e um recurso é criado, o código de retorno é 201. Se a requisição falhar por culpa de algum atributo mal informado, utiliza-se um 400. Se os parâmetros forem todos devidamente informados, mas alguma regra de negócio impediu que a contratação do parcelamento ocorresse com sucesso, utiliza-se um 422.</p>
<h2 id="escrevendo-o-contrato"><a id="escrevendo-o-contrato"></a>Escrevendo o contrato</h2>
<p>A maior parte do trabalho para modelagem de um contrato foi o levantamento que fizemos até este ponto. Daqui pra frente vamos apenas formalizá-lo em um formato que seja interpretado por ferramentas de automação, frameworks, linguagens, catálogos, gateways etc.</p>
<p>Existem algumas linguagens diferentes para declarar contrato de APIs, no entanto, o Swagger ou OAS ( <a href="https://swagger.io/docs/specification/about/">Open API Specification</a> ) é o mais conhecido e suportado.</p>
<p>Como a escrita do contrato em si é a parte mais simples do processo e é amplamente documentada na web, vamos fazer apenas um dos casos que levantamos neste guia e sem entrar nos detalhes da linguagem.</p>
<p>O exemplo a ser escrito em OAS será o <code>GET http://.../cartoes?upgrade=true</code> e o <code>POST http://.../cartoes/{idCartao}/faturas/{idFatura}/parcelamento</code>. Com o conhecimento gerado para montar estas duas URLs, você já será capaz de entender como fazer as outras e terá o conhecimento mínimo para explorar os materiais na web e fazer seus próprios contratos. Detalhes como autenticação e OAUTH também não serão trabalhados neste exemplo.</p>
<p>Vamos percorrer cada trecho do contrato e entender a sua estrutura.</p>
<p>Observe o código abaixo, repare que a escrita está em <a href="https://en.wikipedia.org/wiki/YAML">YAML</a> (que é uma notação que organiza as declarações aninhando com espaços). O OAS permite que o contrato seja escrito também em JSON.</p>
<p>Ali estão definidas a versão do OAS, informações básicas do que se trata o documento e o endereço do servidor onde as URLs deste contrato estão respondendo. Neste guia, até agora usamos as reticências para encurtar as URLs e não ficar repetindo o endereço do servidor o tempo todo, no entanto, no OAS ele deve ser declarado no servers.url.</p>
<pre><code>openapi: '3.0.0'
info:
  title: API do Sistema de Cartões do Banco Dourado.
  version: '1.0'
servers:
  - url: http://www.bancodourado.com.br/cartoes/v1
</code></pre>
<p>Abaixo, preencho os Paths com as URLs, verbos, descrições e parâmetros de entrada e saída que fazem parte da URL.</p>
<p idcartao="" idfatura="">Observe aninhado abaixo do paths, a presença do <strong>/cartoes</strong> e seu verbo <strong>get</strong> e do <strong>/cartoes//faturas//parcelamento</strong> e seu verbo <strong>post</strong>; cada um dos path parameters (parâmetros que vão no path ou URL) e cada um dos query parameters.</p>
<p>Abaixo de cada rota + verbo, podem existir responses ou requestBody. No caso do /cartoes, preencheremos o response do GET indicando que poderá haver uma resposta HTTP 200 e cujo conteúdo é um application/json com um schema que especifica os atributos da entidade. Vamos ver schemas mais pra frente.</p>
<p>Faremos o mesmo para a rota de parcelamento: declararemos que a resposta será um HTTP 200 representando que a contratação ocorreu com sucesso e referenciaremos o schema que criaremos a seguir.</p>
<pre><code>paths:
  /cartoes:
    get:
      summary: Lista de cartões de um cliente.
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/get-request-cartao'
      parameters:
        - schema:
            type: boolean
          in: query
          name: upgrade
          description: Indica se o cartao tem ofertas de upgrade.
  '/cartoes/{idCartao}/faturas/{idFatura}/parcelamento':
    parameters:
      - schema:
          type: string
        name: idCartao
        in: path
        required: true
      - schema:
          type: string
        name: idFatura
        in: path
        required: true
    post:
      summary: Contratação de uma opção de parcelamento para uma fatura.
      tags: []
      responses:
        '200':
          description: Opção de fatura contratada com sucesso.
          content:
            application/json:
              schema:
                type: object
                properties: {}
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/post-request-parcelamento-fatura'
</code></pre>
<p>Agora vamos definir a entidade (ou no OAS: schema) do cartão para que seja usada na rota <code>GET http://.../cartoes?upgrade=true</code> que nomeei como get-request-cartao. E faremos o mesmo para objeto enviado no <code>POST /cartoes/{idCartao}/faturas/{idFatura}/parcelamento</code> que nomeei como post-request-parcelamento-fatura.</p>
<pre><code>components:
  schemas:
    get-request-cartao:
      title: cartao
      type: object
      description: Cartão de crédito
      properties:
        id:
          type: string
          description: Identificador do cartão
          example: '9784364237'
        numero:
          type: string
          description: Numero do cartão mascarado.
          example: '5467********1234'
        nome:
          type: string
          description: Nome do cartão
          example: Cartão XPTO
        nomePortador:
          type: string
          description: Nome do portador do cartão.
          example: José da Silva
        dataValidade:
          type: string
          description: Mês e ano da validade do cartão.
          example: 12/25
        bandeira:
          type: string
          description: Nome da bandeira do cartão de crédito.
          example: Mastercard
        parceiro:
          type: string
          description: Nome do parceiro
          example: Supermercado Grandes Compras
        cvv:
          type: integer
          description: Card Verification Value do cartão.
          example: 987
        dataMelhorCompra:
          type: string
          description: 'Retorna a data referente a melhor data de compra, com referência à data de corte do cartão.'
          example: '2016-02-28'
        bloqueado:
          type: boolean
          description: Indica se o cartão está bloqueado.
          example: false
    post-request-parcelamento-fatura:
      description: Parcelamento de fatura
      type: object
      title: parcelamento-fatura
      properties:
        idConta:
          description: Identificador da conta de débito.
          type: string
          example: '4321098765432109'
        idOferta:
          description: Identificador da oferta selecionada na simulação.
          type: string
          example: 12P1
        valorPagamentoMinimo:
          description: Valor do pagamento mínimo da fatura.
          type: number
          example: 123456.78
        quantidadeParcela:
          description: Número de parcelas a serem pagas
          type: integer
          example: 12
        valorParcela:
          description: Valor de cada parcela.
          type: number
          example: 234.56
        dataPrimeiroVencimento:
          description: Data do vencimento da primeira parcela.
          type: string
          example: '2018-06-20'
        dataPagamentoEntrada:
          description: Data do pagamento da entrada.
          type: string
          example: '2018-05-20'
        valorEntrada:
          description: Valor da entrada.
          type: number
          example: 1000.2
        valorUltimoPagamento:
          description: Valor da última parcela.
          type: number
          example: 134.67
        seguroPrestamista:
          description: Indica se foi contratado o seguro prestamista que garante a quitação de uma dívida no caso de impossibilidade de pagamento por motivos maiores.
          type: boolean
          example: false
      required:
        - idConta
        - idOferta
        - valorPagamentoMinimo
        - quantidadeParcela
        - valorParcela
        - valorEntrada
        - valorUltimoPagamento
        - seguroPrestamista
</code></pre>
<p>Note que na definição do post-request-parcelamento-fatura alguns campos foram declarados na lista do required, pois são obrigatórios no envio.</p>
<p>É isso! Seguindo este padrão, daí pra frente, bastaria criar cada uma das rotas, verbos, requests e responses que especificamos durante a análise.</p>
<h2 id="palavras-finais"><a id="palavras-finais"></a>Palavras finais</h2>
<p>O processo de definir um bom contrato de API envolve conhecer e estudar REST e mais importante ainda, envolve conhecer o seu negócio. Minha experiência com times definindo estes contratos mostra que a maior parte do tempo gasto foi em entender o negócio e identificar cada entidade e como se relacionam. Quanto à escrita do contrato, depois de fazer o primeiro, os analistas tiram de letra.</p>
<p>REST não é apenas uma forma de montar um contrato de API, mas um padrão arquitetural que envolve alguns conceitos e algumas restrições. Nem todas as empresas de partida implementam APIs respeitando todas as restrições. É chamada de RESTfull uma API que respeita todas estas restrições. É chamada de REST a API que respeita todos ou pelo menos alguns dos padrões e restrições. Podemos resumir que RESTfull seria o estado da arte na implementação de uma API REST.</p>
<p>Com frequência teremos que fazer sistemas para expor funcionalidades de sistemas legados, aí surge uma grande dificuldade: equilibrar o que é entendido como ideal com o que já está construído sem as melhores práticas. Logo, nem sempre vamos conseguir atingir o RESTFull.</p>
<p>Assim, conhecer REST conceitualmente é muito importante: quando se junta a dificuldade de entender o negócio com a falta de maestria em REST, as coisas ficam um pouco difíceis. Então, deixo como sugestão que busquem bastante conhecimento em REST primeiro e aproveite as oportunidades dos projetos para na prática aprender a entender o negócio.</p>

</div>
</body>
</html>